#include <stdio.h>
#include <algorithm>
class Solution {
public:

    vector<int> parent;
    vector<int> rank;
    
    int findParent(int p) {
        if(parent[p] != p)
            return findParent(parent[p]);
        
        return p;
    }

    void Union(int n1, int n2) {
        int p1 = findParent(n1);
        int p2 = findParent(n2);

        if (p1 == p2)
         return;

        if (rank[p1] >= rank[p2])
        {
           parent[p2] = p1;
           rank[p1] += rank[p2];
        }
        else
        {
           parent[p1] = p2;
           rank[p2] += rank[p1]; 
        }
    }    
    void resetUF(int n)
    {
        parent.resize(n);
        rank.resize(n);
        for (auto i=0; i<n; i++) parent[i] = i; 
        for (auto i=0; i<n; i++) rank[i] = 1;        
    }

     int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        
        int n = graph.size();
        vector<int> re {};
        int minCNT = INT_MAX;

        for (auto i=0; i<initial.size(); i++){
            vector<int> temp {};
            for (auto j=0; j<n; j++){
                if (j != initial[i]) temp.push_back(j);
            }
            //for (int r=0; r<n-1; r++)
            //  fprintf(stdout,"%d ",temp[r]);
            //fprintf(stdout,"\n"); 

            resetUF(n);
            for (auto r:temp)
              for (auto c:temp)
                if (r != c && graph[r][c])
                  Union(r,c);

            //for (int r=0; r<n; r++)
            //  fprintf(stdout,"%d ",parent[r]);
            //fprintf(stdout,"\n");
            //for (int r=0; r<n; r++)
            //  fprintf(stdout,"%d ",rank[r]);
            //fprintf(stdout,"\n");

            vector<int> var;
            var.resize(n);
            for (auto j=0; j<initial.size(); j++){
                 var[findParent(initial[j])] = rank[findParent(initial[j])];
            }
            //for (int j=0; j<n; j++)
            // fprintf(stdout,"%d ",var[j]);
            //fprintf(stdout,"\n"); 

            int cnt = 0;
            for (auto j=0; j<n; j++){
                 cnt += var[j];
            }
            if (cnt <= minCNT){
                if (cnt < minCNT) re.clear();

                minCNT = cnt;
                re.push_back(initial[i]);
            }

           //fprintf(stdout,"re\n"); 
           //for (int j=0; j<re.size(); j++)
           //  fprintf(stdout,"%d ",re[j]);
           //fprintf(stdout,"\n");             
        }
        sort(re.begin(),re.end());

        return re[0];
    }
};