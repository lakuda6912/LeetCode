#include <stdio.h>
#include <algorithm>
class Solution {
public:

    vector<int> parent;
    vector<int> rank;
    
    int findParent(int p) {
        if(parent[p] != p)
            return findParent(parent[p]);
        
        return p;
    }

    void Union(int n1, int n2) {
        int p1 = findParent(n1);
        int p2 = findParent(n2);

        if (p1 == p2)
         return;

        if (rank[p1] >= rank[p2])
        {
           parent[p2] = p1;
           rank[p1] += rank[p2];
        }
        else
        {
           parent[p1] = p2;
           rank[p2] += rank[p1]; 
        }
    }    
    void resetUF(int n)
    {
        parent.resize(n);
        rank.resize(n);
        for (auto i=0; i<n; i++) parent[i] = i; 
        for (auto i=0; i<n; i++) rank[i] = 1;        
    }
 
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
 
        int n = graph.size();
        resetUF(n);
        for (auto r=0; r<n; r++)
           for (auto c=0; c<n; c++)
             if (r != c && graph[r][c])
                Union(r,c);

        vector<int> malware(n,0);
        for (auto i=0; i<initial.size(); i++) {
          malware[findParent(initial[i])]++;
        }
        //fprintf(stdout,"malware:");
        //for (auto i=0; i<n; i++) {
        //  fprintf(stdout,"%d ",malware[i]);
        //}
        //fprintf(stdout,"\n");
        int maxArea = 0;
        vector<int> re {};
        for (auto i=0; i<initial.size(); i++) {
          if (malware[findParent(initial[i])] == 1){
              if (rank[findParent(initial[i])] >= maxArea)
              {
                if (rank[findParent(initial[i])] > maxArea)
                 re.clear();
                re.push_back(initial[i]);
                maxArea = rank[findParent(initial[i])];
              } 
          }
        }
        //fprintf(stdout,"re: ");
        //for (auto i=0; i<re.size(); i++) {
        //  fprintf(stdout,"%d ",re[i]);
        //}
        //fprintf(stdout,"\n");
        sort(re.begin(),re.end());
        sort(initial.begin(),initial.end());
        if (re.size() > 0){
           return re[0];
        }
        else {
            return initial[0];
        }

        return 0;
    }
};